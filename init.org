#+TITLE: Emacs configuration

This is my literate, mostly self-describing Emacs configuration. The
[[#hooks][footer of this file]] adds an org-mode hook that extracts emacs lisp
blocks from this file into ~init.el~. Almost everything needed to
bootstrap my config is in this file. 

** Installation

1. Clone this repo to ~.emacs.d~.
2. Create an empty ~.emacs.d/custom.el~ if one does not exist. This
   file keeps any machine-local customizations and is not
   version-controlled.
3. Open this file (~init.org~) in emacs. When prompted, trust the file
   in order to allow the ~org-babel-tangle~ hook to be installed. Save
   the file, making a trivial change if necessary, to trigger the
   after-save tangle hook. This creates the ~init.el~.
4. Restart emacs, several times if necessary, to install all of the packages.
5. When emacs starts cleanly, you win! Have a treat.

* Initialization and Package Management
** Bootstrap straight.el, the functional package manager:

#+begin_src emacs-lisp :tangle yes
;;; DO NOT EDIT THIS FILE.
;;; It was exported by org-tangle from init.org.
;;; Edit that instead, s'il vous plaÃ®t.

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

** Wire up straight.el to use-package

This allows use-package calls to delegate to straight.el for
consistency. Just pass ~:straight t~ to ~use-package~.

https://github.com/raxod502/straight.el#integration-with-use-package

#+begin_src emacs-lisp :tangle yes
(straight-use-package 'use-package)
(setq straight-use-package-by-default 't)
#+end_src

* Appearance / Behavior
** Defaults
#+begin_src emacs-lisp :tangle yes
(setq-default c-basic-offset 2)
(setq-default js-indent-level 2)
(setq-default css-indent-offset 2)
(setq-default tab-width 2)
(setq web-mode-markup-indent-offset 2)
(setq web-mode-css-indent-offset 2)
(setq web-mode-code-indent-offset 2)
(setq web-mode-attr-indent-offset 2)
(setq web-mode-attr-value-indent-offset 2)
(setq web-mode-enable-auto-indentation t)
(setq ring-bell-function (lambda ()))
(setq kill-whole-line t)
(defalias 'yes-or-no-p 'y-or-n-p)
(use-package better-defaults)
(add-to-list 'exec-path (substitute-env-vars "$HOME/.cargo/bin"))
(add-to-list 'exec-path (substitute-env-vars "$HOME/.cargo/bin"))
(add-to-list 'exec-path (substitute-env-vars "$HOME/src/elixir-ls/build"))
#+end_src

** Theme and Fonts
#+begin_src emacs-lisp :tangle yes
(load-theme 'leuven)
#+end_src

Zooming (uniformly changing font size in all buffers) via zoom-frm.el:

#+begin_src emacs-lisp :tangle yes
(use-package zoom-frm
  :config

   (define-key ctl-x-map [(control ?+)] 'zoom-in/out)
   (define-key ctl-x-map [(control ?-)] 'zoom-in/out)
   (define-key ctl-x-map [(control ?=)] 'zoom-in/out)
   (define-key ctl-x-map [(control ?0)] 'zoom-in/out)
   (global-set-key (if (boundp 'mouse-wheel-down-event) ; Emacs 22+
                       (vector (list 'control
                                     mouse-wheel-down-event))
                     [C-mouse-wheel])    ; Emacs 20, 21
                   'zoom-in)
   (when (boundp 'mouse-wheel-up-event) ; Emacs 22+
     (global-set-key (vector (list 'control mouse-wheel-up-event))
                     'zoom-out))
)
#+end_src

** Counsel and Swiper (nice interactive in-buffer search)

#+begin_src emacs-lisp :tangle yes
(use-package counsel
  :config
  (counsel-mode)
  (global-set-key (kbd "C-x C-m") 'counsel-M-x))

(use-package swiper
  :config
  (global-set-key (kbd "C-s") 'swiper)
  (global-set-key (kbd "C-c C-r") 'ivy-resume))
#+end_src

** Company (completion)

#+begin_src emacs-lisp :tangle yes
(use-package company
  :config  
  (setq company-tooltip-align-annotations t)
  (setq company-minimum-prefix-length 1))
#+end_src

** Files
A handy missing macro to rename a file and buffer at the same
time. This is almost always what I want when I end up using
`rename-file` in vanilla Emacs.

#+begin_src emacs-lisp :tangle yes
(defun rename-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil))))))
#+end_src

** Windowing system

Start maximized, with toolbar and menubar hidden. This is a callback
to be hooked into ~after-make-frame-functions~ so we can connect many
emacsclients and they all configure their frames.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'default-frame-alist '(font . "Noto Mono 9"))
(defun tweak-new-frame (&optional frame)
  (set-frame-parameter nil 'fullscreen 'maximized)
  (tool-bar-mode 0)
  (menu-bar-mode 0))
(add-hook 'after-make-frame-functions #'tweak-new-frame t)
;; Make sure it gets called if we're interactive
(when (window-system)
  (tweak-new-frame))
#+end_src

** Transient windows
Turn transient windows like Completion into popups that dismiss more easily:
https://www.emacswiki.org/emacs/PopWin

#+begin_src emacs-lisp :tangle yes
(use-package popwin)
#+end_src

** Programming:

FIXME-in-comments (highlight TODO, FIXME, etc):

#+begin_src emacs-lisp :tangle yes
(use-package fic-mode
 :config
 (add-hook 'prog-mode-hook (lambda () (fic-mode 1)))
 (add-hook 'yaml-mode-hook (lambda () (fic-mode 1)))
 (add-hook 'web-mode-hook (lambda () (fic-mode 1)))
 (add-hook 'toml-mode-hook (lambda () (fic-mode 1))))
#+end_src

** Customize (custom.el)

~init.el~ is sacred. Any options set through Customize are cordoned
off into their own file.

#+begin_src emacs-lisp :tangle yes
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

* Global keymaps

Some personal ergonomics:

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-w") 'backward-kill-word)
(global-set-key (kbd "C-x C-k") 'kill-region)
(global-set-key (kbd "C-x b") 'ivy-switch-buffer)
(global-set-key (kbd "M-g") 'goto-line)
#+end_src

Windmove, for tmux-like navigation between windows:

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-S-h") 'windmove-left)
(global-set-key (kbd "C-S-j") 'windmove-down)
(global-set-key (kbd "C-S-k") 'windmove-up)
(global-set-key (kbd "C-S-l") 'windmove-right)
#+end_src

** Prefixes
#+begin_src emacs-lisp :tangle yes
(define-prefix-command 'major-mode-map)
(global-set-key (kbd "M-m") 'major-mode-map)
#+end_src

* Languages
** Agda

Agda is installed separately, and as long as we can find ~agda-mode~
on the exec-path, it should handle setting up Agda for us.

#+begin_src emacs-lisp :tangle yes
;(load-file (let ((coding-system-for-read 'utf-8))
;                (shell-command-to-string (substitute-env-vars "$HOME/.local/bin/agda-mode locate"))))
#+end_src

For speedup, run ~agda-mode compile~ to byte-compile all of the .el
files.

> *Warning*: If you reinstall the Agda mode without recompiling the
> Emacs Lisp files, then Emacs may continue using the old, compiled
> files.

** Caml / OCaml:
#+begin_src emacs-lisp :tangle yes
(use-package tuareg)
#+end_src

** C#
#+begin_src emacs-lisp :tangle yes
(use-package csharp-mode)
#+end_src

** Clojure
#+begin_src emacs-lisp :tangle yes
(use-package clojure-mode)
#+end_src

** Coq
#+begin_src emacs-lisp :tangle yes
(use-package proof-general)

(use-package company-coq
  :config
  (add-hook 'coq-mode-hook #'company-coq-mode))
#+end_src

** Cryptol / SAW
#+begin_src emacs-lisp :tangle yes
(use-package cryptol-mode)
#+end_src

** Dhall
#+begin_src emacs-lisp :tangle yes
(use-package dhall-mode)
#+end_src

** Docker
#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode)
#+end_src

** Elixir
#+begin_src emacs-lisp :tangle yes
(use-package elixir-mode
  :config
  (add-hook 'elixir-mode-hook 'lsp)
  (setq-default lsp-ui-doc-enable nil)
  (setq-default lsp-ui-sideline-enable t)
  (add-hook 'elixir-mode-hook
    (lambda () (add-hook 'before-save-hook 'elixir-format nil t))))

;; https://elixirforum.com/t/tips-syntax-highlight-for-inline-l-liveview-code-in-emacs/26445
(use-package mmm-mode
  :config
  (setq mmm-global-mode 'maybe)
  (setq mmm-parse-when-idle 't)
  (setq mmm-set-file-name-for-modes '(web-mode))
  (custom-set-faces '(mmm-default-submode-face ((t (:background nil)))))
  (let ((class 'elixir-eex)
        (submode 'web-mode)
        (front "^[ ]+~L\"\"\"")
        (back "^[ ]+\"\"\""))
    (mmm-add-classes (list (list class :submode submode :front front :back back)))
    (mmm-add-mode-ext-class 'elixir-mode nil class))

  (define-advice web-mode-guess-engine-and-content-type (:around (f &rest r) guess-engine-by-extension)
    (if (and buffer-file-name (equal "ex" (file-name-extension buffer-file-name)))
      (progn (setq web-mode-content-type "html")
         (setq web-mode-engine "elixir")
         (web-mode-on-engine-setted))
      (apply f r))))

(use-package dap-mode
  :config
  (add-hook 'elixir-mode-hook (lambda () (dap-ui-mode) (dap-mode))))

(use-package exunit
  :after (elixir-mode)
  :bind (:map elixir-mode-map
         ("C-c v a" . exunit-verify-all)
         ("C-c v v" . exunit-verify)
         ("C-c v r" . exunit-rerun)
         ("C-c v 1" . exunit-verify-single)))
#+end_src

** Elm
#+begin_src emacs-lisp :tangle yes
(use-package elm-mode)
#+end_src

** Erlang
#+begin_src emacs-lisp :tangle yes
(use-package erlang)
#+end_src

** Gleam
#+begin_src emacs-lisp :tangle yes
(use-package gleam-mode
  :straight (:host github :repo "MainShayne233/gleam-mode"))
#+end_src

** Haskell

#+begin_src emacs-lisp :tangle yes
(use-package dante
  :after haskell-mode
  :commands 'dante-mode
  :init
  (add-hook 'haskell-mode-hook 'flycheck-mode)
  (add-hook 'haskell-mode-hook 'dante-mode)
  (setq dante-methods-alist
    `(;(styx "styx.yaml" ("styx" "repl" dante-target))
     (stack "stack.yaml" ("stack" "repl" dante-target))
     (nix dante-cabal-nix ("nix-shell" "--pure" "--run" (concat "cabal repl " (or dante-target "") " --builddir=dist/dante")))
     (impure-nix dante-cabal-nix ("nix-shell" "--run" (concat "cabal repl " (or dante-target "") " --builddir=dist/dante")))
     (new-build "cabal.project" ("cabal" "new-repl" (or dante-target (dante-package-name) "") "--builddir=dist/dante"))
     ;(new-impure-nix dante-cabal-new-nix ("nix-shell" "--run" (concat "cabal new-repl " (or dante-target (dante-package-name) "") " --builddir=dist/dante")))
     ;(new-nix dante-cabal-new-nix ("nix-shell" "--pure" "--run" (concat "cabal new-repl " (or dante-target (dante-package-name) "") " --builddir=dist/dante")))
     (nix-ghci ,(lambda (d) (directory-files d t "shell.nix\\|default.nix")) ("nix-shell" "--pure" "--run" "ghci"))
     ;(mafia "mafia" ("mafia" "repl" dante-target))
     (bare-cabal ,(lambda (d) (directory-files d t ".cabal$")) ("cabal" "repl" dante-target "--builddir=dist/dante"))
     (bare-ghci ,(lambda (_) t) ("ghci")))))
  
#+end_src

** GMPL / MathProg
#+begin_src emacs-lisp :tangle yes
(use-package gmpl-mode)
#+end_src

** Golang
#+begin_src emacs-lisp :tangle yes
(use-package go-mode)
#+end_src

** GraphQL
#+begin_src emacs-lisp :tangle yes
(use-package graphql-mode)
#+end_src

** Idris
#+begin_src emacs-lisp :tangle yes
(use-package idris-mode)
#+end_src

** Javascript / Node / nvm
#+begin_src emacs-lisp :tangle yes
(use-package js2-mode)
(use-package nvm)
#+end_src

** Julia
#+begin_src emacs-lisp :tangle yes
(use-package julia-mode)
#+end_src

** LaTeX
#+begin_src emacs-lisp :tangle yes
(use-package latex-preview-pane)
#+end_src

** Lean
#+begin_src emacs-lisp :tangle yes
(use-package lean-mode)
#+end_src

** Markdown
#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode)
#+end_src

** nginx
#+begin_src emacs-lisp :tangle yes
(use-package nginx-mode)
#+end_src

** Nix
#+begin_src emacs-lisp :tangle yes
(use-package nix-mode)
#+end_src

** PHP
#+begin_src emacs-lisp :tangle yes
(use-package php-mode)
#+end_src

** PureScript
#+begin_src emacs-lisp :tangle yes
(use-package purescript-mode)
#+end_src

** Ruby
#+begin_src emacs-lisp :tangle yes
(use-package bundler
  :straight (:host github :repo "endofunky/bundler.el"))
(use-package chruby)
(use-package rspec-mode)
(use-package robe)
#+end_src

** Rust
#+begin_src emacs-lisp :tangle yes
  (use-package rust-mode
    :hook (rust-mode . lsp)
    :config
    (setq rust-format-on-save t))
  (use-package cargo
    :hook (rust-mode . cargo-minor-mode))
  (use-package toml-mode)
  (use-package flycheck-rust
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
  ;; (use-package racer
  ;;   :config
  ;;   (add-hook 'rust-mode-hook #'racer-mode)
  ;;   (add-hook 'racer-mode-hook #'eldoc-mode)
  ;;   (add-hook 'racer-mode-hook #'company-mode))
  ;; (use-package rustfmt
  ;;   :config
  ;;   (add-hook 'rust-mode-hook
  ;;     (lambda ()
  ;;       (add-hook 'before-save-hook #'rustfmt-format-buffer))))
#+end_src

** SASS/SCSS
#+begin_src emacs-lisp :tangle yes
(use-package sass-mode)
(use-package scss-mode)
#+end_src

** Scala
#+begin_src emacs-lisp :tangle yes
(use-package scala-mode)
#+end_src

** Slim
#+begin_src emacs-lisp :tangle yes
(use-package slim-mode)
#+end_src

** Solidity
#+begin_src emacs-lisp :tangle yes
(use-package solidity-mode)
#+end_src

** Systemd
#+begin_src emacs-lisp :tangle yes
(use-package systemd)
#+end_src

** Terraform
#+begin_src emacs-lisp :tangle yes
(use-package terraform-mode)
#+end_src

** TypeScript
#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :config
  (setq-default typescript-indent-level 2))
(use-package tide
  :config
  (defun setup-tide-mode ()
    (interactive)
    (nvm-use-for-buffer)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    ;; company is an optional dependency. You have to
    ;; install it separately via package-install
    ;; `M-x package-install [ret] company`
    (company-mode +1))
  
  ;; aligns annotation to the right hand side
  (setq company-tooltip-align-annotations t)
  
  ;; formats the buffer before saving
  (add-hook 'before-save-hook 'tide-format-before-save)
  
  (add-hook 'typescript-mode-hook #'setup-tide-mode))
#+end_src

** YAML
#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode)
#+end_src

** web-mode
#+begin_src emacs-lisp :tangle yes
(use-package web-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
  (add-hook 'web-mode-hook
            (lambda ()
              (when (string-equal "tsx" (file-name-extension buffer-file-name))
                (fic-mode 1)
                (setup-tide-mode))))
  ;; enable typescript-tslint checker
  (flycheck-add-mode 'typescript-tslint 'web-mode))
(setq web-mode-content-types-alist
  '(("jsx" . "\\.js[x]?\\'")))
#+end_src

* Tools
** flycheck
Enable flycheck globally, but only check on save (the default is every
change, which I find distracting):

#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :config
    (global-flycheck-mode)

    ;; I prefer using a persistent errors pane rather than have this pop
    ;; up in whatever window I happened to be looking in.
    ;(setq flycheck-display-errors-delay 100000)
    (setq flycheck-check-syntax-automatically '(save)))
#+end_src

New experimental setup:

#+begin_src emacs-lisp :tangle yes
(use-package flycheck-posframe
  :after flycheck
  :config
   (add-hook 'flycheck-mode-hook #'flycheck-posframe-mode)
   (setq flycheck-display-errors-delay 0))
#+end_src

** Helm
Helm-dash documentation:
#+begin_src emacs-lisp :tangle yes
(use-package helm-dash)
#+end_src

Helm-projectile (find file in project via scm):
#+begin_src emacs-lisp :tangle yes
(use-package helm-projectile
  :bind (("C-x f" . helm-projectile-find-file-dwim)))
#+end_src

** lsp
#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :commands lsp
  :config 
  (require 'lsp-clients)
  ;(require 'lsp-ui-flycheck)
  (setq-default lsp-prefer-flymake t))

(use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode))
#+end_src

** magit
#+begin_src emacs-lisp :tangle yes
(use-package magit
  :bind (("C-x g" . magit-status)))
#+end_src

** multi-term
#+begin_src emacs-lisp :tangle yes
(use-package multi-term
  :config
  (setq multi-term-program "/bin/zsh")
  ;; Bind mash-RET to "open a dedicated term from this directory"
  (global-set-key (kbd "C-M-s-<return>") #'multi-term-dedicated-toggle)
  (setq multi-term-dedicated-select-after-open-p t)
  ;; Return to the same place in the previous buffer when done
  (setq multi-term-dedicated-close-back-to-open-buffer-p t))
#+end_src
*** TODO a hotkey to open a dedicated multi-term in the git/projectile root of the current 
** multiple-cursors
#+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors)
#+end_src

** org-mode
#+begin_src emacs-lisp :tangle yes
(use-package org
  :config
  ;; Syntax highlighting in org-babel blocks
  (setq org-src-fontify-natively t)
  (setq org-agenda-files '("~/Dropbox/org/"))
  (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
  (setq org-refile-use-outline-path nil)
  (setq org-outline-path-complete-in-steps nil)
  ;; notes go into LOGBOOK drawer
  (setq org-log-into-drawer t)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
  (setq org-todo-keywords
    '((sequence "TODO(t)" "NEXT(n)" "WAIT(w)" "EVENT(e)" "|" "DONE(d)" "CANCELLED(c)")))
  (setq org-capture-templates
    '(("t" "Todo" entry (file "~/Dropbox/org/Refile.org")
       "* TODO %?\n%U" :empty-lines 1)
      ("T" "Todo with Clipboard" entry (file "~/Dropbox/org/Refile.org")
       "* TODO %?\n%U\n   %c" :empty-lines 1)
      ("n" "Note" entry (file "~/Dropbox/org/Refile.org")
       "* NOTE %?\n%U" :empty-lines 1)
      ("N" "Note with Clipboard" entry (file "~/Dropbox/org/Refile.org")
       "* NOTE %?\n%U\n   %c" :empty-lines 1)
      ("e" "Event" entry (file+headline "~/Dropbox/org/Events.org" "Transient")
       "* EVENT %?\n%U" :empty-lines 1)
      ("E" "Event With Clipboard" entry (file+headline "~/Dropbox/org/Events.org" "Transient")
       "* EVENT %?\n%U\n   %c" :empty-lines 1)))
  (setq org-default-notes-file "~/Dropbox/org/TODO.org")
  (add-hook 'org-mode-hook #'auto-revert-mode))
(use-package org-bullets
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
(use-package org-brain)
(use-package helm-org-rifle ;; TODO key bindings
  :config
  (add-hook 'org-mode-hook
    (lambda () 
      (local-set-key (kbd "C-c C-j") 'helm-org-rifle)))) ;; mnemonic: "jump"
#+end_src

** org-reveal
#+begin_src emacs-lisp :tangle yes
;; syntax highlighting
(use-package htmlize) 
(use-package ox-reveal
  :straight (:host github :repo "yjwen/org-reveal"))
#+end_src

** ripgrep
#+begin_src emacs-lisp :tangle yes
(use-package deadgrep
  :config
  (global-set-key (kbd "M-m /") #'deadgrep))
#+end_src

** smartparens
#+begin_src emacs-lisp :tangle yes
(use-package smartparens
  :config
  (smartparens-global-mode 1)
  (add-hook 'prog-mode-hook #'smartparens-strict-mode))
#+end_src

** yasnippet
#+begin_src emacs-lisp :tangle yes
(use-package yasnippet)
#+end_src

* Meta
** Hooks
Builds an ~init.el~ file every time this file is saved.

;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)
;; End:

